# 関数型プログラミングについて
関数型プログラミングは、 「副作用のない関数」だけでプログラミングを行うこと。
なおこの「副作用のない関数」は、純粋関数と呼ばれることもある。

# 副作用
 副作用とは、簡単に言うと、外部の状態を変化させるということ.
 つまり外部の状態を変化させない関数だけでプログラミングを行うことが、 関数型プログラミングとなります。
   
## 副作用の例
- 変数を変更する
- オブジェクトが持っているフィールドの値を書き換える
- 例外やエラーを発生させる
- コンソールから入力を受け取り、出力を出す
- ファイルを読み込む、書き込みをする
- 画面上の GUI を変化させる

## 参照透過性
この副作用のない関数の性質の一つ.
簡単に言えば値と式が交換できる.

```scala worksheet
def square(n: Int): Int = n * n

square(10)
```
この式 square(10) と (10 かける 10 の) 結果である 100 は、たとえプログラムの中で入れ替えても成立する

他にも「副作用を持たない関数」を使うことで

- どこで計算しても問題ないため、並列処理がしやすい
- 関数自体がモジュール性を持っており、再利用性が高く、並行開発がしやすい
- 外部の状態に影響されないため、独立してテストしやすい。また、並列テストしやすい

つまり関数型プログラミングは、我々のプログラミングの生産性や可能性をより高めてくれる たくさんの性質を持っている.

# Scalaの関数
今まで Scala での関数はオブジェクトのメソッドとしてのみ実装してきましたが、 実は関数は、 Scala では 単に Function0 〜 Function22 というトレイトの無名サブクラスのインスタンスとして表現されています。

```scala worksheet
val add = new Function2[Int, Int, Int] {
  def apply(x: Int, y: Int): Int = x + y
}
```

つまり関数を定義するということは、 Function0 〜 Function22 の 無名のサブクラスを作ることと同じ.
https://www.scala-lang.org/files/archive/api/2.12.7/scala/Function0.html
https://www.scala-lang.org/files/archive/api/2.12.7/scala/Function22.html

# 無名関数
先ほどは関数に add 関数を作ったが、毎度毎度 new Function2[Int, Int, Int]... のように書いていると面倒.
シンタックスシュガーで以下のようにかける
```scala worksheet
val add = (x: Int, y: Int) => x + y
```
戻り値については、引数の型から自動的に解決されるためこのように書いて問題ない.

無名関数の一般的な構文は以下.

```scala worksheet
(n1: N1, n2: N2, n3: N3, ...nx: NX) => B
```

n1 から nx までが仮引数の定義で N1 から NX までが仮引数の型.
B は無名関数の本体です。無名関数の返り値の型は通常は B の型から推論される.
先ほど述べたように、Scala の関数は Function0 〜 Function22 までのトレイトの無名サブクラスの
インスタンスですから、引数の最大個数は 22 個になる.

# 関数の型
```scala worksheet
(N1, N2, N3, ...NX) => B の型
```
関数自体を宣言するときにも => が使われる、関数の型を記載する際にも、 => という記号が使われる


# カリー化
ハスケル・カリーという数学者の 名前に由来
たとえば (Int, Int) => Int 型の関数のように複数の引数を取る関数があったとき、
これを Int => Int => Int 型の関数のように、ひとつの引数を取り、
残りの引数を取る関数を返す関数のチェインで表現する.

```scala worksheet
val addCurried = (x: Int) => ((y: Int) => x + y)

addCurried(100)(200)
```

このカリー化は、複数ある引数を途中まで確定させた状態の関数を得て使う場合や、
値と関数を別々な () で引数として受け取りたい場合に利用されるる
また関数だけを別な () で受け取るようにすることで、後ろの方に来る単一の関数に型推論という、
型を推測する機能が付くため、無名関数の引数に型を記述しなくてもよくなるというメリットがある.


このようにカリー化を書くこともできる
ただし、def を使って定義した関数は厳密には関数ではなくメソッドになるので、
先ほど定義した addCurried とは型が異なる.
addCurried(300) のように、1 引数だけを与えて別の関数を返させることもできない.
```scala worksheet
 def addCurried(x: Int)(y: Int): Int = x + y
```

# メソッドとの違い
メソッドと関数の違いについては Scala を勉強する際に注意する必要がある.
本来は def で始まる構文で定義されたものだけがメソッドだが、説明の便宜上、
所属するオブジェクトの無いメソッドや REPL で定義したメソッドを関数と呼んだりすることがある.
書籍や Web でもこの 2 つを意図的に、あるいは無意識に混同している例が多々あるので注意する必要がある.

再度強調すると、Scala におけるメソッドは def で始まる構文で定義されたものであり、
それを関数と呼ぶのはあくまで説明の便宜上である.

なぜメソッドと関数の区別を強調するかというと
**メソッドは第一級の値ではないのに対して関数は第一級の値である** という、大きな違いがあるからだ.
メソッドを引数にする関数、メソッドを返す関数、メソッドが入った変数といったものは Scala には存在しない.

# 高階関数
関数を引数に取ったり関数を返すメソッドや関数のことを高階関数と呼びます。

```scala worksheet
def double(n: Int, f: Int => Int): Int = {
  f(f(n))
}
```
これは与えられた関数 f を 2 回、整数 n に適用する関数 double .
ちなみに、高階関数に渡される関数は適切な名前を付けることができないことも多く、
その場合は f や g などの 1 文字の名前をよく使う（他の関数型プログラミング言語でも同様の慣習がある）

```scala worksheet
scala> double(1, m => m * 2)
res4: Int = 4


scala> double(2, m => m * 3)
res5: Int = 18


scala> double(3, m => m * 4)
res6: Int = 48
```

このように、関数を引数に取る関数を記述したり、利用したりすることは Scala ではよく行われる.

# 再帰関数と末尾再帰最適化

以下の再帰関数で1から100万までの和を計算すると、
`java.lang.StackOverflowError`が発生する.

```scala worksheet
object Main {

  def series(n: Int): Int = {
    if (n == 0) {
      0
    } else {
      series(n - 1) + n
    }
  }

}
```

再帰関数は、メソッドの呼び出しの時に利用されるコールスタックと呼ばれる領域を使い果たし、
このようなエラーを発生させる可能性がある.
コールスタックとは、メソッドの呼び出しの際にその上位の階層の情報を保存しておく領域のこと.

Scala には、再帰関数でこのような StackOverflowError を防ぐための仕組みとして
末尾再帰最適化という機能が用意されている.

`末尾再帰最適化は、再帰関数の呼び出しが必ず関数の末尾に来るような記述としておくことで 内部的にループ処理に書き換えてくれるもの`

末尾再帰最適化がかかっているかどうかを確かめるために 
`@tailrec` というアノテーションを利用する.

さらに先ほどの再帰関数では、
アキュムレーターという、結果を足しあわせておくための引数を利用して、この series メソッドを書き換える.
アキュムレーターは、 英語で accumulator と書き、累算器という意味がある.

```scala worksheet
import scala.annotation.tailrec

object Main {

  @tailrec
  def series(n: Int, acc: Int): Int = {
    if (n == 0) {
      acc
    } else {
      series(n -1, acc + n)
    }
  }
}
```

# まとめ
- 関数型プログラミングとは、副作用のない関数だけでプログラミングを行うこと
- 関数型プログラミングをすることで、モジュール性や並行性が高まり、テストや一般化が容易になる
- Scala において関数は、 FunctionN トレイトの無名サブクラス
- 高階関数は、関数を引数に取ったり関数を返すメソッドや関数のこと
- 再帰関数を書く時には、末尾再帰最適化が必要な場合がある
 