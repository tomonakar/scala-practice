// ---- グラフというデータ構造について ------
// ○で表せる「頂点」と線で表せる「辺」からなるデータ構造
// グラフは、「対象」と「対象の結びつき」を表現する
// 頂点を vertex や node と言い、辺のことを edge という

// グラフにはいくつかの種類がある
// - 辺に向きの無い「無向グラフ」
// - 辺に向きのある「有向グラフ」
// - 全てが連なっている「連結グラフ」 どの2頂点をとってもその頂点間を結ぶ経路が存在する
// - 経路が閉じているもの「閉路」
// - 閉路を持たないもの「木（ツリー）」
// - 有向グラフで閉路を持たないもの「DAG(Directed Acyclec Graph)」という = 有向非巡回グラフ
// --------------------------------------

// assets/01.pngの　AからEまでの頂点を持つ無効グラフをプログラムで表現する
// 上記のようなグラフを記述する場合、「隣接行列」と「隣接リスト」がよく用いられる

object Graph {

  // 隣接行列で表現する場合、以下のようになる。
  // A〜Eを0〜4で表現し, 0の場合は辺がなく、1の場合は辺があるとすると、以下の表となる
  // |from/to| 0 | 1 | 2 | 3 | 4 |
  // |---|---|---|---|---|
  // | 0 | 1 | 1 | 0 | 0 |
  // | 1 | 0 | 0 | 1 | 0 |
  // | 1 | 0 | 0 | 1 | 1 |
  // | 0 | 1 | 1 | 0 | 1 |
  // | 0 | 0 | 1 | 1 | 0 |

  // これをScalaのArray型で表現する
  val matrix: Array[Array[Int]] = Array(
    Array(0, 1, 1, 0, 0),
    Array(1, 0, 0, 1, 0),
    Array(1, 0, 0, 1, 1),
    Array(0, 1, 1, 0, 1),
    Array(0, 0, 1, 1, 0)
  )

  // 上記の場合、存在しない辺も0として記述していることからデータ量が多くなる
  // 隣接リスト使うと隣接する頂点だけをデータとしてもつため、以下のデータ形式となりデータ量が減る
  // A の隣接リスト [B,C]
  // B の隣接リスト [A,D]
  // C の隣接リスト [A,D,E]
  // D の隣接リスト [B,C,E]
  // E の隣接リスト [C,D]

  // 実装すると以下のように表現できる
  val list: Map[Char, Seq[Char]] = Map(
    'A' -> Seq('B', 'C'),
    'B' -> Seq('A', 'D'),
    'C' -> Seq('A', 'D', 'E'),
    'D' -> Seq('B', 'C', 'E'),
    'E' -> Seq('C', 'D')
  )

  // 以下は、隣接リストの辺の情報だけにフォーカスした表現。
  // 辺をオブジェクトとし、辺のコレクションで表現する方法
  case class Edge(from: Char, to: Char)

  val edges = Seq(
    Edge('A', 'B'),
    Edge('A', 'C'),
    Edge('B', 'A'),
    Edge('B', 'D'),
    Edge('C', 'A'),
    Edge('C', 'D'),
    Edge('C', 'E'),
    Edge('D', 'B'),
    Edge('D', 'C'),
    Edge('D', 'E'),
    Edge('E', 'C'),
    Edge('E', 'D')
  )

}
